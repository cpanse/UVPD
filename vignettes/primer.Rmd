---
title: "Vignette Title"
author: "Vignette Author"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


## Require R packages

```{r}
library(UVPD)
```


## ``Hello, World!'' example

```{r}
smis <- c("CC", "c1ccccc1")
(mols <- sapply(smis, parse.smiles, kekulise = FALSE))
for (i in names(mols)) do.aromaticity(mols[[i]])
mols
```

## Load Data

read in csv with CAS numbers and SMILES

```{r}

NORMAN <- read.csv(system.file("extdata/NORMANSusdat_CAS.csv", package = "UVPD"),
                   sep=',', header=TRUE)
```


```{R}
mols <- parse.smiles(as.character(NORMAN$smiles))
```

Add the information suggested by rcdk

__NOTE__: use __try__ function in case something goes wrong
```{r}
for (i in mols) {
  try(do.aromaticity(i))
  try(do.typing(i))
  try(do.isotopes(i))
}
length(mols)
```


compute fingerprint; 
```{r}
fps <- lapply(mols, function(x){try(get.fingerprint(x, type='extended'))})
table(sapply(fps, class))
```


idx.corrupt contains corrupt smile codes?
```{r}

(idx.corrupt <- which(sapply(fps, class) != "fingerprint"))

idx.correct <- which(sapply(fps, class) == "fingerprint")
```

## Compute Distance Matrix


conduct random experiment. select 1000 random items.
```{r}
set.seed(1)

n <-  length(fps[idx.correct])
idx.smp <- sample(n, 1000)


fp.sim.tanimoto <- fingerprint::fp.sim.matrix(fps[idx.correct][idx.smp],
	method='tanimoto')

fp.dist <- as.dist(fp.sim.tanimoto)

image(log( fp.sim.tanimoto))
```

## clustering using kmeans


```{r}

km <- kmeans(fp.dist, 3)

table(km$cluster)

```

## clustering using hclust

```{r}
hc <- hclust(fp.dist)
plot(hc)
```


## PCR

```{r}

pr <- princomp(fp.sim.tanimoto)
biplot(pr)

```

## MDS


```{r}
```


```{r eval=FALSE}
fp.sim.tanimoto <- fingerprint::fp.sim.matrix(fps[idx.correct], method='tanimoto')
save(fp.sim.tanimoto, file='/scratch/fp.RData')

```
